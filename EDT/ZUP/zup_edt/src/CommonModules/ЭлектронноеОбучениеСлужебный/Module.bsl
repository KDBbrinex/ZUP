#Область СлужебныеПроцедурыИФункции

#Область РаботаСЧислами

// Возвращает случайное число.
//
Функция СлучайноеЧисло(Мин, Макс, НачальноеЧисло = Неопределено) Экспорт
	
	Если НачальноеЧисло = Неопределено Тогда
		ГСЧ = Новый ГенераторСлучайныхЧисел();
	Иначе
		ГСЧ = Новый ГенераторСлучайныхЧисел(НачальноеЧисло);
	КонецЕсли;
	
	Возврат ГСЧ.СлучайноеЧисло(Мин, Макс);	

КонецФункции 

#КонецОбласти

#Область РаботаСКоллекциями

// Перемешивает элементы массива в случайном порядке.
//
Функция ПеремешатьМассив(ВходМассив) Экспорт
	
	ДлинаМассива = ВходМассив.Количество();
	
	СуммаСлучайная  = СлучайноеЧисло(1, 100);
	Добавить = СлучайноеЧисло(1, 100, СуммаСлучайная + ДлинаМассива);
	
	Для А = 0 По ДлинаМассива-1 Цикл 
		
		Следующий1 = СлучайноеЧисло(0, ДлинаМассива-1, СуммаСлучайная);
		Следующий2 = СлучайноеЧисло(0, ДлинаМассива-1, СуммаСлучайная+Следующий1+Добавить);

		СледующийЗначение = ВходМассив[Следующий2]; 
		ВходМассив[Следующий2] = ВходМассив[Следующий1]; 
		ВходМассив[Следующий1] = СледующийЗначение; 
		
		СуммаСлучайная = СуммаСлучайная + Следующий1 + Добавить;
		
	КонецЦикла;
	
	Возврат ВходМассив;
	
КонецФункции

// Если в коллекции значений есть свойство, возвращает Истина.
//
Функция ЕстьСвойствоВКоллекции(Коллекция, ИмяСвойства, ИсключитьНеопределенныеЗначения = Ложь) Экспорт
	
	ЕстьСвойство = Ложь;
	
	Если ТипЗнч(Коллекция) = Тип("Структура") Тогда
		ЕстьСвойство = Коллекция.Свойство(ИмяСвойства);
	КонецЕсли;
	
	Если ТипЗнч(Коллекция) = Тип("СтрокаТаблицыЗначений") Тогда		
		ЕстьСвойство = ?(Коллекция.Владелец().Колонки.Найти(ИмяСвойства) = Неопределено, Ложь, Истина);		
	КонецЕсли;	
	
	Если НЕ ЕстьСвойство Тогда
		
		Возврат Ложь;
		
	Иначе
		
		Если ЕстьСвойство И ИсключитьНеопределенныеЗначения Тогда
			Возврат ?(Коллекция[ИмяСвойства] = NULL ИЛИ Коллекция[ИмяСвойства] = Неопределено, Ложь, Истина);
		Иначе
			Возврат ЕстьСвойство;
		КонецЕсли;
		
	КонецЕсли;	
	
КонецФункции

#КонецОбласти

#Область РаботаСПеречислениями

// Возвращает имя перечисления.
//
Функция ИмяЗначенияПеречисления(ЗначениеПеречисления) Экспорт

	Если НЕ ЗначениеЗаполнено(ЗначениеПеречисления) Тогда
		Возврат "";	
	КонецЕсли;
	
	Возврат XMLстрока(ЗначениеПеречисления); 
	
КонецФункции

Функция ИсключитьЗначенияПеречисленияИзСпискаВыбора(Параметры, ДанныеВыбора, ИмяПеречисления, СтандартнаяОбработка) Экспорт
	
	Если Параметры.Свойство("ИсключитьЗначения") Тогда
		
		СтандартнаяОбработка = Ложь;
		
		ДанныеВыбора = Новый СписокЗначений;

		Запрос = Новый Запрос;
		Запрос.Текст = 
			"ВЫБРАТЬ
			|	Перечисление.Ссылка
			|ИЗ
			|	Перечисление."+ИмяПеречисления+" КАК Перечисление
			|
			|УПОРЯДОЧИТЬ ПО
			|	Перечисление.Порядок";

		Результат = Запрос.Выполнить();

		ВыборкаДетальныеЗаписи = Результат.Выбрать();

		МассивИсключений = Параметры.ИсключитьЗначения;
		
		Пока ВыборкаДетальныеЗаписи.Следующий() Цикл
			
			Если МассивИсключений.Найти(ВыборкаДетальныеЗаписи.Ссылка) = Неопределено Тогда
			
				Элемент = ДанныеВыбора.Добавить();
				Элемент.Значение = ВыборкаДетальныеЗаписи.Ссылка;
				Элемент.Представление = ВыборкаДетальныеЗаписи.Ссылка;
				
			КонецЕсли;

		КонецЦикла;
		
	КонецЕсли;
	
КонецФункции

#КонецОбласти

#Область РаботаСДокументами

Процедура ПровестиДокументы(Документы, РежимЗаписи = Неопределено, ДополнительныеСвойства = Неопределено) Экспорт
	
	Если ТипЗнч(Документы) = Тип("Массив") Тогда
		МассивДокументов = Документы;
	Иначе
		МассивДокументов = Новый Массив;
		МассивДокументов.Добавить(Документы);
	КонецЕсли;
	
	Для каждого Документ Из МассивДокументов Цикл
	
		ДокументОбъект = Документ.ПолучитьОбъект();
		
		Если ДополнительныеСвойства <> Неопределено Тогда
		
			Для каждого Свойство Из ДополнительныеСвойства Цикл
				ДокументОбъект.ДополнительныеСвойства.Вставить(Свойство.Ключ, Свойство.Значение);
			КонецЦикла;
			
		КонецЕсли;
		
		Если РежимЗаписи = Неопределено Тогда
			РежимЗаписи = РежимЗаписиДокумента.Проведение;
		КонецЕсли;
			
		Попытка 
			ДокументОбъект.Заблокировать();
		Исключение
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСТР("ru = 'Не удалось заблокировать объект %1'"),
				Строка(ДокументОбъект));
		КонецПопытки;
			
		ДокументОбъект.Записать(РежимЗаписи);
		ДокументОбъект.Разблокировать();
	
	КонецЦикла;
	
КонецПроцедуры

// Перепроводит все документы из переданной выборки.
//
Процедура ПерепровестиВыборкуДокументов(ВыборкаДетальныеЗаписи, РежимЗаписи = Неопределено, ДополнительныеСвойства = Неопределено) Экспорт
	
	Пока ВыборкаДетальныеЗаписи.Следующий() Цикл
		ПровестиДокументы(ВыборкаДетальныеЗаписи.Ссылка, РежимЗаписи, ДополнительныеСвойства);
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти

#Область РаботаСоСправочниками

// Возвращает ссылку на элемент справочника по его идентификатору.
//
Функция ЭлементСправочникаПоИдентификатору(Знач ИмяСправочника, Знач УникальныйИдентификатор) Экспорт
	
	Если ТипЗнч(УникальныйИдентификатор) = Тип("Строка") Тогда
		УникальныйИдентификатор  = Новый УникальныйИдентификатор(УникальныйИдентификатор);
	КонецЕсли;
	
	Возврат Справочники[ИмяСправочника].ПолучитьСсылку(УникальныйИдентификатор);
	
КонецФункции

Функция ИмяСправочникаПоСсылке(СсылкаНаЭлементСправочника) Экспорт
	
	ПолноеИмяТаблицы = ОбщегоНазначения.ИмяТаблицыПоСсылке(СсылкаНаЭлементСправочника);
	ИмяСправочника = Сред(ПолноеИмяТаблицы, СтрДлина("Справочник.")+1);	
	
	Возврат ИмяСправочника;
	
КонецФункции

#КонецОбласти

#Область ФорматированныйДокумент

// Позволяет получить HTML представление форматированного документа
// для последующего размещения в виде страницы HTML.
//
Функция ПредставлениеФорматированногоДокументаДляВыгрузкиHTML(ФорматированныйДокумент, ИдентификаторОбъекта, КодДанных = "", ВключитьДвоичныеДанные = Ложь, ВключитьHTMLДанные = Истина, ОтносительныйПуть = "") Экспорт
	
	Перем ТекстHTML;
	Перем Вложения;
	
	Представление = Новый Структура("ПредставлениеHTML, ЕстьВложения, ДвоичныеДанные, ИдентификаторКаталога", "", Ложь, Неопределено, "");
	
	Если ФорматированныйДокумент = Неопределено Тогда
		Возврат Представление;
	КонецЕсли;
	
	ФорматированныйДокумент.ПолучитьHTML(ТекстHTML, Вложения);
	
	// Получаем вложения
	//	

	Если Вложения.Количество() > 0 Тогда
		
		Представление.ЕстьВложения = Истина;
		
		Если ВключитьДвоичныеДанные Тогда
			
			ВременныйКаталогДляВложений = ПолучитьИмяВременногоФайла("");
			ЭлектронноеОбучениеСлужебныйКлиентСервер.НовыйКаталог(ВременныйКаталогДляВложений);
			ВременныйКаталогДляВложений = ЭлектронноеОбучениеСлужебныйКлиентСервер.ДобавитьКонечныйРазделительПути(ВременныйКаталогДляВложений);			
			
			Для каждого Элемент Из Вложения Цикл
				
				ПолныйПутьКФайлу = ВременныйКаталогДляВложений + Элемент.Ключ + ЭлектронноеОбучениеСлужебныйКлиентСервер.РасширениеКартинки(Элемент.Значение.Формат());
				Элемент.Значение.Записать(ПолныйПутьКФайлу);
			
			КонецЦикла;
			
			ПолноеИмяАрхиваZIP = ПолучитьИмяВременногоФайла(".zip");
			
			ФайлZIP = Новый ЗаписьZipФайла(ПолноеИмяАрхиваZIP,,,МетодСжатияZIP.Копирование);			
			ФайлZIP.Добавить(ВременныйКаталогДляВложений + "*.*", РежимСохраненияПутейZIP.СохранятьОтносительныеПути,  РежимОбработкиПодкаталоговZIP.ОбрабатыватьРекурсивно);			
			ФайлZIP.Записать();
			
			Представление.ДвоичныеДанные = Новый ДвоичныеДанные(ПолноеИмяАрхиваZIP);
						
			Попытка
				УдалитьФайлы(ПолноеИмяАрхиваZIP);
			Исключение
				ЗаписатьОшибкуВЖурналРегистрации(
					СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Не удалось удалить временный файл
					|%1 по причине: %2'"), ПолноеИмяАрхиваZIP, КраткоеПредставлениеОшибки(ИнформацияОбОшибке()))
				);
			КонецПопытки;
			
			Попытка
				УдалитьФайлы(ВременныйКаталогДляВложений);
			Исключение
				ЗаписатьОшибкуВЖурналРегистрации(
					СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Не удалось удалить временный файл
					|%1 по причине: %2'"), ВременныйКаталогДляВложений, КраткоеПредставлениеОшибки(ИнформацияОбОшибке()))
				);
			КонецПопытки;
			
		КонецЕсли;
		
	КонецЕсли;
	
	// Получаем идентификатор каталога
	//
	
	Постфикс = ИзучениеЭлектронныхКурсовСлужебный.ПостфиксРесурсаДляВыгрузки(КодДанных);
	
	Представление.ИдентификаторКаталога = Строка(ИдентификаторОбъекта) + Постфикс;
	
	// Заменяем пути к картинкам и получаем тело сообщения
	//
	
	Если ВключитьHTMLДанные Тогда
	
		ЧтениеHTML = Новый ЧтениеHTML;
		ЧтениеHTML.УстановитьСтроку(ТекстHTML);
		ПостроительDOM = Новый ПостроительDOM;
		ДокументHTML = ПостроительDOM.Прочитать(ЧтениеHTML);
		
		ОтносительныйПутьККартинкам = ?(ЗначениеЗаполнено(ОтносительныйПуть), ОтносительныйПуть + "/", "") + Представление.ИдентификаторКаталога + "/";
		
		Для каждого КартинкаHTML Из ДокументHTML.Картинки Цикл
			
			ЭтоURL = ?(СтрНайти(КартинкаHTML.Источник, ":") > 0, Истина, Ложь);
			            
			Картинка = Неопределено;
			
			Если ЗначениеЗаполнено(КартинкаHTML.Источник)
				И НЕ ЭтоURL
				И Вложения.Свойство(КартинкаHTML.Источник, Картинка) Тогда
				
				Если ТипЗнч(Картинка) = Тип("Картинка") Тогда
					Расширение = ЭлектронноеОбучениеСлужебныйКлиентСервер.РасширениеКартинки(Картинка.Формат());
					ИмяФайлаВложения = КартинкаHTML.Источник + Расширение;
				Иначе
					ИмяФайлаВложения = КартинкаHTML.Источник;
				КонецЕсли;
				
				КартинкаHTML.Источник = ОтносительныйПутьККартинкам + ИмяФайлаВложения;
				
			КонецЕсли;
			
		КонецЦикла;

		ИсправитьПроблемныеСсылкиФорматированногоДокумента(ДокументHTML);
		
		ЗаписьHTML = Новый ЗаписьHTML;
		ЗаписьHTML.УстановитьСтроку();

		ЗаписьDOM = Новый ЗаписьDOM;
		ЗаписьDOM.Записать(ДокументHTML, ЗаписьHTML); 

		// Выделяем тело форматированного документа и возвращаем
		//
		
		Представление.ПредставлениеHTML = ТелоHTMLДокумента(ЗаписьHTML.Закрыть());
		
	КонецЕсли;
		
	Возврат Представление;
	
КонецФункции

// Позволяет получить HTML представление форматированного документа
// для последующего размещения в поле HTML документа без выгрузки на диск.
//
Функция ПредставлениеФорматированныйДокументДляПоляHTML(ФорматированныйДокумент, ИдентификаторФормы) Экспорт
	
	ТекстHTML = "";
	Вложения  = Новый Структура;
	
	Если ФорматированныйДокумент = Неопределено Тогда
		Возврат ТекстHTML;	
	КонецЕсли;
	
	ФорматированныйДокумент.ПолучитьHTML(ТекстHTML, Вложения);

	// Заменяем пути к картинкам и получаем тело сообщения
	
	Если Вложения.Количество() > 0 Тогда
	
		ЧтениеHTML = Новый ЧтениеHTML;
		ЧтениеHTML.УстановитьСтроку(ТекстHTML);
		
		ПостроительDOM = Новый ПостроительDOM;
		ДокументHTML = ПостроительDOM.Прочитать(ЧтениеHTML);
		
		Для каждого КартинкаHTML Из ДокументHTML.Картинки Цикл
			
			Картинка = Неопределено;
			
			Вложения.Свойство(КартинкаHTML.Источник, Картинка);
			
			Если ТипЗнч(Картинка) = Тип("Картинка") Тогда
				КартинкаHTML.Источник = ПоместитьВоВременноеХранилище(Картинка, ИдентификаторФормы);
			КонецЕсли;
			
		КонецЦикла;

		ИсправитьПроблемныеСсылкиФорматированногоДокумента(ДокументHTML);
		
		ЗаписьHTML = Новый ЗаписьHTML;
		ЗаписьHTML.УстановитьСтроку();

		ЗаписьDOM = Новый ЗаписьDOM;
		ЗаписьDOM.Записать(ДокументHTML, ЗаписьHTML); 

		ТекстHTML = ЗаписьHTML.Закрыть();
		
	КонецЕсли;
		
	// Выделяем тело форматированного документа и возвращаем
	
	Возврат ТелоHTMLДокумента(ТекстHTML);	
		
КонецФункции

// Возвращает содержимое тега <body>.
//
Функция ТелоHTMLДокумента(Знач ТекстHTMLДокумента)
	
    ТекстНРег = НРег(ТекстHTMLДокумента);
	
    НачалоТегаТела = Найти(ТекстНРег, "<body>");
	Если НачалоТегаТела = 0 Тогда
		НачалоТегаТела = Найти(ТекстНРег, "<body ");
	КонецЕсли;
	Если НачалоТегаТела = 0 Тогда
		Возврат ТекстHTMLДокумента;
	КонецЕсли;
	ТекстHTMLДокумента = Сред(ТекстHTMLДокумента, НачалоТегаТела+5, СтрДлина(ТекстНРег));
	КонецТегаТела = Найти(ТекстHTMLДокумента, ">");
	ТекстHTMLДокумента = Сред(ТекстHTMLДокумента, КонецТегаТела+1, СтрДлина(ТекстHTMLДокумента));
	
 	ТекстНРег = НРег(ТекстHTMLДокумента);
	
    НачалоТегаТела = Найти(ТекстНРег, "</body>");
	Если НачалоТегаТела = 0 Тогда
		НачалоТегаТела = Найти(ТекстНРег, "<body ");
	КонецЕсли;
	Если НачалоТегаТела = 0 Тогда
		Возврат ТекстHTMLДокумента;
	КонецЕсли;
	
	ТекстHTMLДокумента = Сред(ТекстHTMLДокумента, 1, НачалоТегаТела-1);
	
	Возврат ТекстHTMLДокумента;
	
КонецФункции

Функция ЭтоПустойHTMLДокумент(Знач ТекстHTMLДокумента) Экспорт
	
	Если НЕ ЗначениеЗаполнено(СокрЛП(ТекстHTMLДокумента)) Тогда
		Возврат Истина;
	КонецЕсли;
	
	ЧтениеHTML = Новый ЧтениеHTML;
	ЧтениеHTML.УстановитьСтроку(ТекстHTMLДокумента);
	
	ПостроительDOM = Новый ПостроительDOM;
	ДокументHTML = ПостроительDOM.Прочитать(ЧтениеHTML);
	
	Если ДокументHTML.Тело = Неопределено Тогда
		
		Возврат Истина;
		
	Иначе
		
		Если НЕ ЗначениеЗаполнено(СокрЛП(ДокументHTML.Тело.ТекстовоеСодержимое))
			И ДокументHTML.Картинки.Количество() = 0 Тогда
			
			Возврат Истина
			
		Иначе
			
			Возврат Ложь;
			
		КонецЕсли;
		
	КонецЕсли;
	
КонецФункции

Функция JSONВДанные(Знач СтрокаJSON, Знач ДлинаСтроки = Неопределено, НомерСимвола = 1) Экспорт
	
	Если ДлинаСтроки = Неопределено Тогда
		ДлинаСтроки = СтрДлина(СтрокаJSON);
	КонецЕсли;
	
	Если НомерСимвола > ДлинаСтроки Тогда
		Возврат "";
	КонецЕсли;
	
	Символ = Сред(СтрокаJSON, НомерСимвола, 1);
	
	Если Символ = """" Тогда // Строка в кавычках
		
		Результат = "";
		
		НомерСимволаНачалаСтроки = НомерСимвола; // Номер символа, с которого начинается поиск значения
		НомерСимволаНачалаПоиска = НомерСимвола; // Номер символа, с которого ищется значение в цикле
		КонецСтрокиНайден = Ложь;
		ДлинаЗначения = 0;
		
		Пока НомерСимволаНачалаПоиска < ДлинаСтроки И НЕ КонецСтрокиНайден Цикл
		
			ПодстрокаПоиска = Сред(СтрокаJSON, НомерСимволаНачалаПоиска + 1); // Подстрока для поиска закрывающей кавычки
			
			НомерСимволаКавычки = Найти(ПодстрокаПоиска, Символ); // Номер символа закрывающей кавычки
			
			Если НомерСимволаКавычки = 0 Тогда
				Прервать;
			КонецЕсли;
			
			Если Сред(ПодстрокаПоиска, НомерСимволаКавычки - 1, 1) = "\" Тогда
				НомерСимволаНачалаПоиска = НомерСимволаНачалаПоиска + НомерСимволаКавычки;
			Иначе
				КонецСтрокиНайден = Истина;
			КонецЕсли;
			
			ДлинаЗначения = ДлинаЗначения + НомерСимволаКавычки;
			
		КонецЦикла;
		
		Если НЕ КонецСтрокиНайден Тогда
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Окончание строки не найдено (%1)'"), Строка(НомерСимвола));
		КонецЕсли;
		
		Результат = Сред(СтрокаJSON, НомерСимволаНачалаСтроки + 1, ДлинаЗначения - 1);
		
		Результат = ЭлектронноеОбучениеСлужебныйКлиентСервер.СтрокаИзJSСтроки(Результат);
		
		НомерСимвола = НомерСимвола + ДлинаЗначения + 1; 
		
	ИначеЕсли Символ = "[" Тогда // Массив
		
		Результат = Новый Массив;
		
		НомерСимвола = НомерСимвола + 1;
		
		Символ = Сред(СтрокаJSON, НомерСимвола, 1);

		Если Символ = "]" Тогда
			
			НомерСимвола = НомерСимвола + 1; // Пустой массив
			
		Иначе
		
			Пока НомерСимвола <= ДлинаСтроки Цикл
				
				Результат.Добавить(JSONВДанные(СтрокаJSON, ДлинаСтроки, НомерСимвола)); // Рекурсия
				
				Символ = Сред(СтрокаJSON, НомерСимвола, 1);
				
				Если Символ = "]" Тогда																					
					
					НомерСимвола = НомерСимвола + 1; 
					
					Прервать;
					
				ИначеЕсли Символ = "," Тогда																				
					
					НомерСимвола = НомерСимвола + 1;
						
				Иначе     
					
					ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Недопустимый символ (%1)'"), Строка(НомерСимвола));
				
				КонецЕсли;
				
			КонецЦикла;
			
		КонецЕсли;
			
	ИначеЕсли Символ = "{" Тогда // Объект
		
		Результат = Новый Структура;
		
		НомерСимвола = НомерСимвола + 1;

		Символ = Сред(СтрокаJSON, НомерСимвола, 1);
		
		Если Символ = "}" Тогда	 // Пустой объект.													
			
			НомерСимвола = НомерСимвола + 1;

		Иначе
			
			НомерЭлемента = 1;
			
			Пока НомерСимвола <= ДлинаСтроки Цикл
				
				КлючЭлемента = JSONВДанные(СтрокаJSON, ДлинаСтроки, НомерСимвола); // Рекурсия
				
				Символ = Сред(СтрокаJSON, НомерСимвола, 1);
				
				Если Символ = ":" Тогда
					
					НомерСимвола = НомерСимвола + 1;
					
				Иначе
					
					ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Недопустимый символ разделения свойств объекта (%1)'"), Строка(НомерСимвола));
					
				КонецЕсли;
				
				ЗначениеЭлемента = JSONВДанные(СтрокаJSON, ДлинаСтроки, НомерСимвола); // Рекурсия
				
				Результат.Вставить(КлючЭлемента, ЗначениеЭлемента);
				
				Символ = Сред(СтрокаJSON, НомерСимвола, 1);
				
				Если Символ = "}" Тогда
					
					НомерСимвола = НомерСимвола + 1;
					
					Прервать;
					
				ИначеЕсли  Символ = "," Тогда
					
					НомерСимвола = НомерСимвола + 1;
					
				Иначе
					
					ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Недопустимый символ разделения объектов (%1)'"), Строка(НомерСимвола));
					
				КонецЕсли;
				
				НомерЭлемента = НомерЭлемента + 1;
				
			КонецЦикла;
			
		КонецЕсли;
		
	Иначе // Примитивные типы
		
		Если Сред(СтрокаJSON, НомерСимвола, 4) = "null" Тогда
			
			НомерСимвола = НомерСимвола + 4;
			
			Результат = NULL;
			
		ИначеЕсли Сред(СтрокаJSON, НомерСимвола, 4) = "true" Тогда
			
			НомерСимвола = НомерСимвола + 4;
			
			Результат = Истина;
			
		ИначеЕсли Сред(СтрокаJSON, НомерСимвола, 5) = "false" Тогда
			
			НомерСимвола = НомерСимвола + 5;
			
			Результат = Ложь;
			
		ИначеЕсли Сред(СтрокаJSON, НомерСимвола, 9) = "undefined" Тогда
			
			НомерСимвола = НомерСимвола + 9;
			
			Результат = Неопределено;
			
		Иначе
			
			НачалоЧисла = НомерСимвола;
			
			Пока Найти("-+0123456789.", Символ) > 0 И НомерСимвола <= ДлинаСтроки Цикл
				НомерСимвола = НомерСимвола + 1;
				Символ = Сред(СтрокаJSON, НомерСимвола, 1);
			КонецЦикла;
			
			Результат = СтроковыеФункцииКлиентСервер.СтрокаВЧисло(Сред(СтрокаJSON, НачалоЧисла, НомерСимвола - НачалоЧисла));
			
			Если Результат = Неопределено Тогда
				ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Ошибка преобразования в число (%1)'"), Сред(СтрокаJSON, НачалоЧисла, НомерСимвола - НачалоЧисла));
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Функция ДанныеВJSON(Знач Данные) Экспорт
	
	Если ТипЗнч(Данные) = Тип("Массив") Тогда
		
		СтрокаJSON = "[";
		
		Если Данные.Количество() > 0 Тогда
		
			Для каждого ЭлементМассива Из Данные Цикл
				СтрокаJSON = СтрокаJSON + ДанныеВJSON(ЭлементМассива) + ",";	
			КонецЦикла;
			
			СтрокаJSON = Сред(СтрокаJSON, 1, СтрДлина(СтрокаJSON) - 1); // Убираем последнюю запятую
			
		КонецЕсли;
			
		СтрокаJSON = СтрокаJSON + "]";
		
	ИначеЕсли ТипЗнч(Данные) = Тип("Структура") Тогда
		
		СтрокаJSON = "{";
		
		Если Данные.Количество() > 0 Тогда
		
			Для каждого ЭлементСтруктуры Из Данные Цикл
				СтрокаJSON = СтрокаJSON + """" + ЭлементСтруктуры.Ключ + """" + ":" + ДанныеВJSON(ЭлементСтруктуры.Значение) + ",";	
			КонецЦикла;
			
			СтрокаJSON = Сред(СтрокаJSON, 1, СтрДлина(СтрокаJSON) - 1); // Убираем последнюю запятую
			
		КонецЕсли;
			
		СтрокаJSON = СтрокаJSON + "}";
		
	ИначеЕсли ТипЗнч(Данные) = Тип("ТаблицаЗначений") Тогда
		
		СтрокаJSON = "[";
		
		Если Данные.Количество() > 0 Тогда
			
			Для каждого СтрокаТаблицы Из Данные Цикл
				
				СтрокаJSON = СтрокаJSON + "{";
				
				Для каждого КолонкаТаблицы Из Данные.Колонки Цикл
					СтрокаJSON = СтрокаJSON + """" + КолонкаТаблицы.Имя + """" + ":" + ДанныеВJSON(СтрокаТаблицы[КолонкаТаблицы.Имя]) + ",";
				КонецЦикла;
				
				СтрокаJSON = Сред(СтрокаJSON, 1, СтрДлина(СтрокаJSON) - 1); // Убираем последнюю запятую
				
				СтрокаJSON = СтрокаJSON + "},";
				
			КонецЦикла;
			
			СтрокаJSON = Сред(СтрокаJSON, 1, СтрДлина(СтрокаJSON) - 1); // Убираем последнюю запятую
			
			
		КонецЕсли;
		
		СтрокаJSON = СтрокаJSON + "]";
		
	ИначеЕсли ТипЗнч(Данные) = Тип("ДеревоЗначений") ИЛИ ТипЗнч(Данные) = Тип("КоллекцияСтрокДереваЗначений") Тогда
		
		СтрокаJSON = "[";
		
		Если ТипЗнч(Данные) = Тип("ДеревоЗначений") Тогда
			СтрокиДерева = Данные.Строки;
		Иначе
			СтрокиДерева = Данные;
		КонецЕсли;
		
		Если СтрокиДерева.Количество() > 0 Тогда
			
			Для каждого СтрокаДерева Из СтрокиДерева Цикл
				
				СтрокаJSON = СтрокаJSON + "{";
				
				ВладелецСтроки = СтрокаДерева.Владелец();
				
				Для каждого КолонкаДерева Из ВладелецСтроки.Колонки Цикл
					СтрокаJSON = СтрокаJSON + """" + КолонкаДерева.Имя + """" + ":" + ДанныеВJSON(СтрокаДерева[КолонкаДерева.Имя]) + ",";
				КонецЦикла;
				
				СтрокаJSON = СтрокаJSON + """ПодчиненныеЭлементы"":" + ДанныеВJSON(СтрокаДерева.Строки);
				
				СтрокаJSON = СтрокаJSON + "},";
				
			КонецЦикла;
			
			СтрокаJSON = Сред(СтрокаJSON, 1, СтрДлина(СтрокаJSON) - 1); // Убираем последнюю запятую
			
		КонецЕсли;
		
		СтрокаJSON = СтрокаJSON + "]";
		
		
	ИначеЕсли ТипЗнч(Данные) = Тип("Число") Тогда
		
		СтрокаJSON = ЭлектронноеОбучениеСлужебныйКлиентСервер.ЧислоВСтроку(Данные);	
		
	ИначеЕсли ТипЗнч(Данные) = Тип("Булево") Тогда
		
		СтрокаJSON = ?(Данные, "true", "false");
		
	ИначеЕсли ТипЗнч(Данные) = Тип("Неопределено") Тогда
		
		СтрокаJSON = "null";
		
	ИначеЕсли ТипЗнч(Данные) = Тип("NULL") Тогда
		
		СтрокаJSON = "null";		
		
	ИначеЕсли ТипЗнч(Данные) = Тип("Дата") Тогда
		
		СтрокаJSON = ЭлектронноеОбучениеСлужебныйКлиентСервер.ЧислоВСтроку(ЭлектронноеОбучениеСлужебныйКлиентСервер.ДатаВЧислоJS(Данные));
		
	ИначеЕсли ТипЗнч(Данные) = Тип("ХранилищеЗначения") Тогда
		
		СтрокаJSON = Данные.Получить();
		
	ИначеЕсли ТипЗнч(Данные) <> Тип("Строка") И ОбщегоНазначения.ЗначениеСсылочногоТипа(Данные) Тогда
		
		ВидСсылки = ОбщегоНазначения.ВидОбъектаПоСсылке(Данные);
		
		Если ВидСсылки = "Перечисление" Тогда
			СтрокаJSON = """" + ИмяЗначенияПеречисления(Данные) + """";
		Иначе
			СтрокаJSON = """" + Строка(Данные.УникальныйИдентификатор()) + """";
		КонецЕсли;
		
	Иначе
		
		СтрокаJSON = """" + ЭлектронноеОбучениеСлужебныйКлиентСервер.JSСтрока(Данные, Ложь) + """";
		
	КонецЕсли;
	
	Возврат СтрокаJSON;
	
КонецФункции

Функция НаименованиеЭлементаИзТекста(ФорматированныйДокументИлиСтрока) Экспорт
	
	Если ТипЗнч(ФорматированныйДокументИлиСтрока) = Тип("Строка") Тогда
		НаименованиеНовогоЭлемента = ФорматированныйДокументИлиСтрока;
	Иначе
		НаименованиеНовогоЭлемента = ФорматированныйДокументИлиСтрока.ПолучитьТекст();
	КонецЕсли;
	
	НаименованиеНовогоЭлемента = СокрЛП(НаименованиеНовогоЭлемента);
	
	ПереводСтроки = СтрНайти(НаименованиеНовогоЭлемента, Символы.ПС);
	
	Если ПереводСтроки > 0 Тогда
		НаименованиеНовогоЭлемента = Лев(НаименованиеНовогоЭлемента, ПереводСтроки);
	КонецЕсли;

	НаименованиеНовогоЭлемента = СокрЛП(НаименованиеНовогоЭлемента);
	
	Возврат НаименованиеНовогоЭлемента;	
	
КонецФункции

#КонецОбласти

#Область РаботаСЗапросами

Процедура ДобавитьОтборКЗапросу(Запрос, ТекстОтбора) Экспорт
	
	Если ТипЗнч(Запрос) = Тип("СхемаЗапроса") Тогда
		
		Конструктор = Запрос;
		
		Конструктор.ПакетЗапросов[0].Операторы[0].Отбор.Добавить(ТекстОтбора);
		
	Иначе
		
		Конструктор = Новый СхемаЗапроса;
		Конструктор.УстановитьТекстЗапроса(Запрос.Текст);
		
		Конструктор.ПакетЗапросов[0].Операторы[0].Отбор.Добавить(ТекстОтбора);
		
		Запрос.Текст = Конструктор.ПолучитьТекстЗапроса();	
		
	КонецЕсли;
	
КонецПроцедуры

Функция КолонкиЗапроса(Запрос) Экспорт
	
	СхемаЗапроса = Новый СхемаЗапроса;
	СхемаЗапроса.УстановитьТекстЗапроса(Запрос.Текст);
	
	Колонки = Новый Массив;
	
	Для каждого Колонка Из СхемаЗапроса.ПакетЗапросов[0].Колонки Цикл
		Колонки.Добавить(Колонка.Псевдоним);
	КонецЦикла;
	
	Возврат Колонки;
	
КонецФункции

Функция СсылкаСуществуетВБазе(Ссылка, СчитатьПомеченныеНаУдалениеОтсутствующими = Ложь) Экспорт
	
	Если НЕ ЗначениеЗаполнено(Ссылка) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если СчитатьПомеченныеНаУдалениеОтсутствующими Тогда
		
		ДанныеСсылки = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(Ссылка, "Ссылка, ПометкаУдаления");
		
		Возврат ?(ЗначениеЗаполнено(ДанныеСсылки.Ссылка) И ДанныеСсылки.ПометкаУдаления = ЛОЖЬ, Истина, Ложь);
		
	Иначе
		
		Возврат ЗначениеЗаполнено(ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Ссылка, "Ссылка"));
		
	КонецЕсли;
	
КонецФункции

#КонецОбласти

#Область Системное

// Записывает в журнал регистрации описание ошибки.
//
// Параметры:
//	СообщениеОбОшибке - Строка - строковое представление ошибки.
//	Данные - Произвольный - данные, к которым относится сообщение об ошибке.
//
Процедура ЗаписатьОшибкуВЖурналРегистрации(СообщениеОбОшибке, Данные = Неопределено) Экспорт
	
	ЗаписьЖурналаРегистрации(
		ЭлектронноеОбучениеСлужебныйКлиентСервер.СобытиеЖурналаРегистрацииЭлектронныхКурсов(),
		УровеньЖурналаРегистрации.Ошибка,
		,
		Данные,
		СообщениеОбОшибке);
	
КонецПроцедуры

Функция СоставПодсистемыРазработки() Экспорт
		
	МетаданныеХраненияДанныхКурсов = Новый Массив;
	МетаданныеХраненияДанныхКурсов.Добавить(Метаданные.Справочники.ВариантыОтветовНаТестовыеВопросы);
	МетаданныеХраненияДанныхКурсов.Добавить(Метаданные.Справочники.КатегорииВариантовОтветовТестовыхВопросов);
	МетаданныеХраненияДанныхКурсов.Добавить(Метаданные.Справочники.ОпределенияТерминовЭлектронныхГлоссариев);
	МетаданныеХраненияДанныхКурсов.Добавить(Метаданные.Справочники.ОтборыТемЭлектронныхРубрикаторов);
	МетаданныеХраненияДанныхКурсов.Добавить(Метаданные.Справочники.ПоставщикиЭлектронныхКурсов);
	МетаданныеХраненияДанныхКурсов.Добавить(Метаданные.Справочники.СодержаниеЭлектронныхГлоссариев);
	МетаданныеХраненияДанныхКурсов.Добавить(Метаданные.Справочники.СодержаниеЭлектронныхКурсов);
	МетаданныеХраненияДанныхКурсов.Добавить(Метаданные.Справочники.СтраницыЭлементовЭлектронныхКурсов);
	МетаданныеХраненияДанныхКурсов.Добавить(Метаданные.Справочники.ТемыЭлектронныхРубрикаторов);
	МетаданныеХраненияДанныхКурсов.Добавить(Метаданные.Справочники.ТеорияЭлектронныхКурсов);
	МетаданныеХраненияДанныхКурсов.Добавить(Метаданные.Справочники.ТерминыЭлектронныхГлоссариев);
	МетаданныеХраненияДанныхКурсов.Добавить(Метаданные.Справочники.ТестовыеВопросы);
	МетаданныеХраненияДанныхКурсов.Добавить(Метаданные.Справочники.УчебныеПрограммныеПродукты);
	МетаданныеХраненияДанныхКурсов.Добавить(Метаданные.Справочники.ФасетыТестовыхВопросов);
	МетаданныеХраненияДанныхКурсов.Добавить(Метаданные.Справочники.ЭлектронныеГлоссарии);
	МетаданныеХраненияДанныхКурсов.Добавить(Метаданные.Справочники.ЭлектронныеКурсы);
	МетаданныеХраненияДанныхКурсов.Добавить(Метаданные.Справочники.ЭлектронныеРесурсы);
	МетаданныеХраненияДанныхКурсов.Добавить(Метаданные.Справочники.ЭлектронныеРубрикаторы);
	МетаданныеХраненияДанныхКурсов.Добавить(Метаданные.Справочники.ЭлектронныеТесты);
	МетаданныеХраненияДанныхКурсов.Добавить(Метаданные.Справочники.ЭлементыЭлектронныхРесурсов);
	МетаданныеХраненияДанныхКурсов.Добавить(Метаданные.Справочники.ЭлементыЭлектронныхРесурсовПрисоединенныеФайлы);
	
	Возврат МетаданныеХраненияДанныхКурсов;
	
КонецФункции

#КонецОбласти

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Процедура ИсправитьПроблемныеСсылкиФорматированногоДокумента(ДокументHTML) 
	
	Гиперссылки = ДокументHTML.ПолучитьЭлементыПоИмени("a");

	Для каждого ЭлементВебСсылки Из Гиперссылки Цикл		
		ЭлектронноеОбучениеСлужебныйКлиентСервер.ИсправитьПроблемнуюСсылкуФорматированногоДокумента(ЭлементВебСсылки.Гиперссылка);		
	КонецЦикла;	
	
КонецПроцедуры

#КонецОбласти

